# CS145 Recommendation System Competition - Checkpoint 1

## Content-Based Recommenders Implementation

This implementation focuses on content-based recommendation approaches that leverage user and item attributes to make effective recommendations. We have implemented three different approaches and combined them in an ensemble to maximize revenue.

### Implemented Approaches

1. **K-Nearest Neighbors (KNN)**
   - Uses cosine similarity to find similar items based on their features
   - Implements user-based and item-based similarity
   - Features are normalized using StandardScaler
   - Hyperparameters:
     - k_neighbors = 5
     - metric = 'cosine'

2. **LightGBM**
   - Gradient boosting framework for binary classification
   - Predicts purchase likelihood based on user and item features
   - Features are normalized using StandardScaler
   - Hyperparameters:
     - num_leaves = 31
     - learning_rate = 0.05
     - feature_fraction = 0.9
     - bagging_fraction = 0.8
     - bagging_freq = 5

3. **Neural Network**
   - Multi-layer perceptron with dropout for regularization
   - Binary classification with sigmoid activation
   - Features are normalized using StandardScaler
   - Architecture:
     - Input layer: concatenated user and item features
     - Hidden layers: [128, 64] with ReLU activation
     - Output layer: 1 unit with sigmoid activation
   - Hyperparameters:
     - dropout = 0.2
     - learning_rate = 0.001
     - batch_size = 256
     - epochs = 10

### Feature Processing

- **Numerical Features**
  - Standardization using StandardScaler
  - Separate scalers for user and item features

- **Categorical Features**
  - One-hot encoding through PySpark's built-in functionality
  - Handled automatically in the data pipeline

### Ranking Strategy

The final recommendations are generated by:
1. Getting predictions from each model
2. Combining predictions with equal weights (1/3 each)
3. Ranking items by combined relevance score
4. Selecting top-k items for each user

### Files

- `content_based_recommenders.py`: Individual recommender implementations
  - `KNNRecommender`
  - `LightGBMRecommender`
  - `NeuralRecommender`
  - `FeatureProcessor` helper class

- `my_recommender.py`: Main recommender class that combines all approaches
  - Implements the required interface
  - Handles model training and prediction
  - Combines predictions from all models

### Usage

```python
from my_recommender import MyRecommender

# Initialize recommender
recommender = MyRecommender(seed=42)

# Train models
recommender.fit(log, user_features, item_features)

# Generate recommendations
recommendations = recommender.predict(
    log=log,
    k=10,
    users=users,
    items=items,
    user_features=user_features,
    item_features=item_features,
    filter_seen_items=True
)
```

### Dependencies

- numpy
- pandas
- scikit-learn
- torch
- lightgbm
- pyspark

### Future Improvements

1. **Feature Engineering**
   - Create interaction features between user and item attributes
   - Add temporal features from interaction history
   - Implement feature selection based on importance

2. **Model Tuning**
   - Grid search for optimal hyperparameters
   - Cross-validation for more robust evaluation
   - Dynamic model weights based on performance

3. **Ranking Optimization**
   - Incorporate item prices into relevance scores
   - Add position bias correction
   - Implement diversity-aware ranking 